<br style="clear:both;height:1em;">
	<div id="leftcol">
		<div class="nav-logo">
			<a href="index.php"><img src="logo.png" style="margin-left:10px; width:155px"/></a>
		</div>
		<ul id="leftnav">
		<li class="separator"><div class="separator">
		<img src="triangle.gif" style="height:12px; margin-right: 2px; display:none"  /><img src="triangle-90.gif" style="display:none; margin-right: 2px" height="12px" />
		<a href="sigma_2.php">Introduction</a></div>
		</li>
		<li class="separator"><div class="separator">
		<img src="triangle.gif" style="height:12px; margin-right: 2px; "  /><img src="triangle-90.gif" style="display:none; margin-right: 2px" height="12px" />
		<a href="sigma_3.php">Reference Documentation</a></div>
		<ul style="display: none;" id="subToc_sigma_3.html">
		<li id="overview.html" ><a href="overview.php" >Overview</a></li>
		</ul>
		</li>
		</ul>
	</div>
	<div id="midcolumn">
		<a name="overview" ></a>
		<span style="float:left; border-top: 1px dotted #d4d4dd; margin-left: 0; margin-top: 5px;
			padding: 5px 0;
			padding-top: 5px;"></span><a style="float: right" href="#">Top</a>
			<br style="clear:both"></br>
			<h1>Overview</h1>
			<div class="toc">
			  <ul>
			    <li><a href="overview.php#overview_4.php" >Basics</a></li>
			    <li><a href="overview.php#structinv.php" >Structural Invariants</a></li>
			    <li><a href="overview.php#overview_6.php" >Drawbacks</a></li>
			    <li><a href="overview.php#overview_7.php" >Why Scala?</a></li>
			  </ul>
			</div>
			<p>
			The main difference between an external and internal DSL is the level of abstraction they can work with.
			While in the former, appropriate concepts can be freely chosen, the latter must always operate on the concepts found in the host language.
			In our case however, thanks to the following features, we can seamlessly write similar powerful OCL-like expressions:
			</p>
			<p>
			<ol>
			  <li>The EMF generator transforms the model concepts into Java code i.e. model classifiers maps into Java classes, structural and behavioral features into appropriate methods.</li>
			  <li>Scala allows one to omit parenthesis in methods without parameters so that similar OCL-like object navigation expressions can be written:
			      <span class="inlinecode">self.getMembership.getParticipant.getDateOfBirth</span>
			      The <em>noise</em> generated by successive <em>get</em> calls can be removed from these expressions by generating (using the EMF code generator dynamic templates) additional methods without the <span class="inlinecode">get</span> prefix that simply delegate their execution to the corresponding getters.
			      This way the above expression becomes the same as the one in OCL:
			      <span class="inlinecode">self.membership.participant.dateOfBirth</span>
			  </li>
			  <li>With the large number of collection operations with support of higher-order functions we can get OCL-like collection navigation but in a more uniform way. For example, a selection of customer cards whose transactions are worth more than 10000 points is expressed in OCL as follows:
			      <div class="literallayout">
			  	<div class="incode">
			  		<p class="code">
			  			self.cards-&gt;select(<br/>
			  			&nbsp;&nbsp;transactions-&gt;collect(points)-&gt;sum()&nbsp;&gt;&nbsp;10000)
			  		</p>
			  	</div>
			  </div>
			  
			      and in Scala:
			      <div class="literallayout">
			  	<div class="incode">
			  		<p class="code">
			  			self.cards&nbsp;filter&nbsp;(<br/>
			  			&nbsp;&nbsp;_.transactions.map(_.points).sum&nbsp;&gt;&nbsp;10000)
			  		</p>
			  	</div>
			  </div>
			  
			      The <span class="inlinecode">_</span> is used to as a placeholder for parameters in the anonymous function instead of specifying a concrete name:
			      <div class="literallayout">
			  	<div class="incode">
			  		<p class="code">
			  			self.cards&nbsp;filter&nbsp;(c&nbsp;=&gt;<br/>
			  			&nbsp;&nbsp;c.transactions.map(t&nbsp;=&gt;&nbsp;t.points).sum&nbsp;&gt;&nbsp;10000)
			  		</p>
			  	</div>
			  </div>
			  
			  </li>
			</ol>
			</p>
			<p>
			Besides, since we manipulate the EMF generated Java code, we have a support for multiple models out of the box as it only means accessing classes from different packages.
			The Java generics are also supported in Scala.
			</p>
			<a name="overview_4" ></a>
			<h2>Basics</h2>
			<p>
			The main usage of our DSL is to enrich EMF models with
			<ol>
			  <li>structural constraints,</li>
			  <li>derived features definition,</li>
			  <li>operations bodies implementation.</li>
			</ol>
			
			Each of these constructs is represented as a Scala object method with an appropriate signature. <div class="todo" >
			ref to EMF integration
			</div>
			
			The first parameter of these methods is always the surrounding context representing the contextual instance (like <span class="inlinecode">self</span> in OCL).
			The other parameters and return type depends on the concrete construct:
			<ul>
			  <li><p>
			  <em>Derived property</em>
			      The return type is the type of the property itself.
			      The following function defines a code that will be executed by EMF when a derived property <span class="inlinecode">printedName</span>, defined in a <span class="inlinecode">Customer</span> class, is accessed:
			  </p>
			  <p>
			      <div class="literallayout">
			  	<div class="incode">
			  		<p class="code">
			  			<span class="keyword">def</span>&nbsp;getPrintedName&nbsp;(self:&nbsp;Customer):&nbsp;String&nbsp;=&nbsp;<br/>
			  			&nbsp;&nbsp;self.owner.title&nbsp;+&nbsp;<span class="string">"&nbsp;"</span>&nbsp;+&nbsp;self.owner.name
			  		</p>
			  	</div>
			  </div>
			  
			  </p>
			  </li>
			  <li><p>
			  <em>Operation body</em>
			      Additional parameters and the return type represent the operation parameters and its type.
			      Following the same pattern, the function below defines the code for the <span class="inlinecode">getTransaction</span> operation from the <span class="inlinecode">CustomerCard</span> class, which has two parameters of type <span class="inlinecode">Date</span> and returns a set of <span class="inlinecode">Transaction</span> references:
			  </p>
			  <p>
			      <div class="literallayout">
			  	<div class="incode">
			  		<p class="code">
			  			<span class="keyword">def</span>&nbsp;invokeGetTransactions(self:&nbsp;CustomerCard,&nbsp;<br/>
			  			&nbsp;&nbsp;until:&nbsp;Date,&nbsp;from:&nbsp;Date):&nbsp;Set[Transaction]&nbsp;=&nbsp;<br/>
			  			&nbsp;&nbsp;self.transactions&nbsp;filter&nbsp;(&nbsp;<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&gt;&nbsp;t.date.isAfter(from)&nbsp;&amp;&amp;&nbsp;<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.date.isBefore(until)&nbsp;)
			  		</p>
			  	</div>
			  </div>
			  
			  </p>
			  </li>
			</ul>
			
			The invariant method signature is discussed in section~<a href="overview.php#structinv.php" title="Go to &quot;Structural Invariants&quot;">Structural Invariants</a>.
			</p>
			<a name="overview_4_2" ></a>
			<h3>Extensibility</h3>
			<p>
			Beside all the functionality that is brought by its standard library, the Scala language counters the limited expressiveness of OCL by leveraging the extensive amount of existing Java libraries.
			To use any of them is only a matter of adding a new dependency to the project.
			</p>
			<p>
			The real Scala extensibility, however, lies in the ability to extend existing types, statically and in a type safe way.
			For example, in Scala there is no logical operator equivalence to OCL <span class="inlinecode">implies</span>.
			Of course we could simply define a function that takes two boolean expressions and returns their logical implication, but this would feel very unnatural to use.
			With Scala, we can define this function to be a method on an existing boolean type by using the <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=179766" >Pimp my Library</a> approach:
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						<span class="keyword">class</span>&nbsp;ExtendedBoolean(a:&nbsp;Boolean)&nbsp;{<br/>
						&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;implies(b:&nbsp;=&gt;&nbsp;Boolean)&nbsp;=&nbsp;!a&nbsp;||&nbsp;b<br/>
						}<br/>
						<span class="comment">//&nbsp;add&nbsp;an&nbsp;implicit&nbsp;conversion&nbsp;between&nbsp;the&nbsp;types<br/>
						</span><span class="keyword">implicit</span>&nbsp;<span class="keyword">def</span>&nbsp;extendedBoolean(a:&nbsp;Boolean)&nbsp;=&nbsp;<br/>
						&nbsp;&nbsp;<span class="keyword">new</span>&nbsp;ExtendBoolean(a)
					</p>
				</div>
			</div>
			</p>
			<p>
			With the above definitions imported one can now use the new method directly and it feels like being part of the language:
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						a&nbsp;=&nbsp;<span class="keyword">true</span>;&nbsp;b&nbsp;=&nbsp;<span class="keyword">false</span>;&nbsp;c&nbsp;=&nbsp;a&nbsp;implies&nbsp;b
					</p>
				</div>
			</div>
			</p>
			<p>
			Using the same pattern we can create other missing OCL operations like <span class="inlinecode">closure</span>, but also create completely new constructs.
			</p>
			<a name="overview_4_3" ></a>
			<h3>Reusability</h3>
			<p>
			Scala allows both imperative and functional language constructs.
			This allows one to break the complex and long expressions into smaller pieces and store the intermediate values into local variables in order to improve the overall readability.
			The reusability of expressions can be easily achieved by simply organizing these expressions into object methods and libraries that can be shared across models and projects.
			</p>
			<p>
			We can push the reusability even further as Scala also supports <em>structural typing</em>.
			Thanks to this feature one can write a very generic expression that can be applied across different and completely unrelated models.
			For example:
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						<span class="keyword">def</span>&nbsp;validateNonEmptyName(self:&nbsp;<br/>
						&nbsp;&nbsp;{<span class="keyword">def</span>&nbsp;name:&nbsp;String})&nbsp;=&nbsp;!self.name.isEmpty
					</p>
				</div>
			</div>
			
			represents a generic invariant checking that an attribute <span class="inlinecode">name</span> is non empty. It can be applied to any class regardless of its type.
			</p>
			<a name="overview_4_4" ></a>
			<h3>Handling Undefined and Invalid Values</h3>
			<p>
			When evaluated, some expressions in OCL can result into invalid or undefined values such as when an empty collection is traversed or an unset reference is navigated.
			Since neglecting them will lead to null pointer exceptions, we also need to handle these cases in Scala.
			</p>
			<p>
			In order to simplify the code we make use of the Scala <abbr title="scala.Option" >Option</abbr> class.
			As the name suggests, it is just a simple abstract container that wraps around an instance of some type <span class="inlinecode">T</span> which represents an optional value.
			The two possible instances are <abbr title="scala.Some" >Some</abbr> and <abbr title="scala.None" >None</abbr> denoting whether there is an actual value for <span class="inlinecode">T</span>.
			</p>
			<p>
			For instance, in the previous example, we checked if a name attribute is non empty string.
			However, if the multiplicity of this attribute had been defined as <span class="inlinecode">0..1</span>, in the cases where the name had not been set the code will throw a null pointer exception.
			The EMF code generator does not make any difference between <span class="inlinecode">0..1</span> and <span class="inlinecode">1..1</span> and outputs the same getter signature:
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						<span class="keyword">public</span>&nbsp;String&nbsp;getName();
					</p>
				</div>
			</div>
			
			%
			However, we can simply extend the EMF code generator dynamic templates and implicitly generate <abbr title="scala.Option" >Option</abbr> return type:
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						<span class="keyword">public</span>&nbsp;scala.Option&lt;String&gt;&nbsp;name()&nbsp;{<br/>
						&nbsp;&nbsp;&nbsp;&nbsp;scala.Option.apply(<span class="keyword">this</span>.getName());<br/>
						}
					</p>
				</div>
			</div>
			
			Because we use a different name for getters (without the <span class="inlinecode">get</span>) the resulting class is still compatible with the rest of the EMF world.
			</p>
			<p>
			As the Scala documentation <a href="http://www.scala-lang.org/api/current/scala/Option.html" >suggests</a> the most idiomatic way to use an <abbr title="scala.Option" >Option</abbr> instance is to treat it as a collection or monad, which results in a very concise and null pointer safe implementation:
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						self.name.filter(!_.isEmpty).getOrElse(<span class="keyword">false</span>)
					</p>
				</div>
			</div>
			</p>
			<a name="overview_4_5" ></a>
			<h3>Type Casts</h3>
			<p>
			Another often used Scala construct is type <em>pattern matching</em>.
			It helps us in simplifying type casts in OCL, which are often used when constraining metamodels.
			Instead of an expression like:
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						<span class="keyword">if</span>&nbsp;self.oclIsKindOf(Customer)&nbsp;then<br/>
						&nbsp;&nbsp;self.oclAsType(Customer).someAction()<br/>
						<span class="keyword">else</span><br/>
						&nbsp;&nbsp;<span class="comment">//&nbsp;something&nbsp;else<br/>
						</span>endif
					</p>
				</div>
			</div>
			
			one can simply write:
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						self&nbsp;<span class="keyword">match</span>&nbsp;{<br/>
						&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;c:&nbsp;Customer&nbsp;=&gt;&nbsp;c.someAction()<br/>
						&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;_&nbsp;=&gt;&nbsp;<span class="comment">//&nbsp;something&nbsp;else<br/>
						</span>}
					</p>
				</div>
			</div>
			</p>
			<a name="structinv" ></a>
			<h2>Structural Invariants</h2>
			<p>
			The improved support of invariant constructs is addressed by flexible return types of the invariant functions.
			We need to be able not only to specify whether an invariant holds on a certain object, but in case it does not, we should say why, how severe the problem is and also be able to provide a support for automatic repair of such inconsistencies (where applicable).
			</p>
			<p>
			Therefore a function representing an invariant can return either:
			<ol>
			  <li>A simple boolean representing whether an invariant holds on <span class="inlinecode">self</span>.
			      <div class="literallayout">
			  	<div class="incode">
			  		<p class="code">
			  			<span class="keyword">def</span>&nbsp;validateOfAge(self:&nbsp;Customer)&nbsp;=&nbsp;self.age&nbsp;&gt;=&nbsp;18
			  		</p>
			  	</div>
			  </div>
			  
			  </li>
			  <li>A string representing an error message in case it does not.
			      <div class="literallayout">
			  	<div class="incode">
			  		<p class="code">
			  			<span class="keyword">def</span>&nbsp;validateOfAge(self:&nbsp;Customer):&nbsp;Option[String]=&nbsp;<br/>
			  			&nbsp;&nbsp;self.age&nbsp;&gt;=&nbsp;18&nbsp;<span class="keyword">match</span>&nbsp;{<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="keyword">true</span>&nbsp;=&gt;&nbsp;None<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;<span class="keyword">false</span>&nbsp;=&gt;&nbsp;Some(<span class="string">"The&nbsp;person&nbsp;%s&nbsp;is&nbsp;under&nbsp;age"</span>&nbsp;<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;format&nbsp;self.printedName)<br/>
			  			&nbsp;&nbsp;}
			  		</p>
			  	</div>
			  </div>
			  
			      In this case we use the <abbr title="scala.Option" >Option</abbr> construct to avoid using <span class="inlinecode">null</span> as a valid return value.
			  </li>
			  <li>An object encapsulating the additional details.
			      <div class="literallayout">
			  	<div class="incode">
			  		<p class="code">
			  			<span class="keyword">def</span>&nbsp;validateDefinesGetInstance(self:&nbsp;UMLClazz)&nbsp;=&nbsp;{<br/>
			  			&nbsp;&nbsp;self.features<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;.find(_.name&nbsp;==&nbsp;<span class="string">"getInstance"</span>)&nbsp;<span class="keyword">match</span>&nbsp;{<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;Some(_)&nbsp;=&gt;&nbsp;Success<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">case</span>&nbsp;None&nbsp;=&gt;&nbsp;Error(<span class="string">"Missing&nbsp;getInstance"</span>,<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QuickFix(<span class="string">"Add&nbsp;a&nbsp;getInstance&nbsp;operation"</span>,&nbsp;{<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clazz:&nbsp;UMLClazz&nbsp;=&gt;<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clazz.features&nbsp;+=&nbsp;create[UMLFeature]&nbsp;{<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;op&nbsp;=&gt;&nbsp;op.setName(<span class="string">"getInsatnce"</span>)<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...<br/>
			  			</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}))<br/>
			  			&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
			  			}
			  		</p>
			  	</div>
			  </div>
			  
			  </li>
			</ol>
			</p>
			<p>
			Context definition and invariant dependency are solved by annotations that are processed by the EMF custom validator.
			<div class="literallayout">
				<div class="incode">
					<p class="code">
						@satisfies(<span class="string">"DefineGetInstance"</span>)<br/>
						<span class="keyword">def</span>&nbsp;validateGetInstanceIsStatic(self:&nbsp;UMLClazz)
					</p>
				</div>
			</div>
			</p>
			<p>
			The validation functions are not called directly but via a proxy that ensures each invariant is called for a specific instance at most once.
			In order to be able to implement all the above we also need to extend both the user interface and the runtime part of the EMF validator.
			</p>
			<p>
			Since referencing the dependent invariants as strings is not very practical,  we are currently looking into how the upcoming Scala 2.10 macros can help us in building a type safe alternative to the annotations.
			</p>
			<a name="overview_6" ></a>
			<h2>Drawbacks</h2>
			<p>
			Obviously there are also some shortcomings in our approach.
			</p>
			<p>
			First, since the implementation of an invariant or a derived property can contain arbitrary code, by default there is no way to make sure they are side-effect free.
			One way to verify this would be by using external checker such as <a href="http://types.cs.washington.edu/checker-framework/current/checkers-manual.html" >IGJ</a>.
			These checkers work as Java language extensions and can verify that an object may not be mutated through a read only reference (a reference annotated by <span class="inlinecode">@ReadOnly</span> annotation).
			</p>
			<p>
			Second, another problem is in the loss of formal reasoning and analysis.
			Nevertheless the analysis part related to performance can be solved using a regular profiler.
			</p>
			<p>
			Finally, in the DSL, we do not support some of the constructs related to postconditions.
			</p>
			<a name="overview_7" ></a>
			<h2>Why Scala?</h2>
			<p>
			While there are other languages that could be used to build an internal DSL, we find Scala a particularly good fit for our purposes.
			It is a modern general purpose language that runs on the top of a JVM, and was designed from the start to be an extensible language for building <a href="http://www.scala-lang.org/node/1403" >internal DSLs</a>.
			It combines both object-oriented and functional style of programming with static typing that uses type inference to provide type safety without adding unnecessary syntactic clutter.
			It is also well supported by the major tool vendors and has already established an active community.
			</p>
		<div id="disqus_thread"></div>
		<script type="text/javascript" src="documentationRoot.js"></script>
		<script type="text/javascript">
		    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
		    var disqus_shortname = 'xtext'; // required: replace example with your forum shortname
		
		    // The following are highly recommended additional parameters. Remove the slashes in front to use.
		    var disqus_identifier = 'overview';
		    var disqus_url = documentationRoot+'overview.php';
		
		    /* * * DON'T EDIT BELOW THIS LINE * * */
		    (function() {
		        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
		        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
		    })();
		</script>
 		<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	</div>
	<br style="clear:both;height:1em;">
